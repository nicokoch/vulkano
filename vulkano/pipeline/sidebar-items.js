initSidebarItems({"mod":[["blend","Defines how the color output of the fragment shader is written to the attachment.There are three kinds of color attachments for the purpose of blending:Attachments with a floating-point, fixed point format. Attachments with a (non-normalized) integer format. Attachments with a normalized integer format. For floating-point and fixed-point formats, the blending operation is applied. For integer formats, the logic operation is applied. For normalized integer formats, the logic operation will take precedence if it is activated. Otherwise the blending operation is applied."],["cache","Cache the pipeline objects to disk for faster reloads.A pipeline cache is an opaque type that allow you to cache your graphics and compute pipelines on the disk.You can create either an empty cache or a cache from some initial data. Whenever you create a graphics or compute pipeline, you have the possibility to pass a reference to that cache. The Vulkan implementation will then look in the cache for an existing entry, or add one if it doesn't exist.Once that is done, you can extract the data from the cache and store it."],["input_assembly",""],["multisample","State of multisampling.Multisampling allows you to ask the GPU to run the rasterizer to generate more than one sample per pixel.For example, if `rasterization_samples` is 1 then the fragment shader, depth test and stencil test will be run once for each pixel. However if `rasterization_samples` is `n`, then the GPU will pick `n` different locations within each pixel and assign to each of these locations a different depth value. Depth and stencil test will then be run `n` times.In addition to this, the `sample_shading` parameter is the proportion (between 0.0 and 1.0) or the samples that will be run through the fragment shader. For example if you set this to 1.0, then all the sub-pixel samples will run through the shader and get a different value. If you set this to 0.5, about half of the samples will run through the shader and the other half will get their values from the ones which went through the shader.If `alpha_to_coverage` is true, then the alpha value of the fragment will be used in an implementation-defined way to determine which samples get disabled or not. For example if the alpha value is 0.5, then about half of the samples will be discarded. If you render to a multisample image, this means that the color will end up being mixed with whatever color was undernearth, which gives the same effect as alpha blending.If `alpha_to_one` is true, the alpha value of all the samples will be forced to 1.0 (or the maximum possible value) after the effects of `alpha_to_coverage` have been applied."],["raster","Stage when triangles are turned into pixels.The rasterization is the stage when collections of triangles are turned into collections of pixels or samples."],["vertex",""],["viewport",""]],"struct":[["GraphicsPipeline","The template parameter contains the descriptor set to use with this pipeline, and the renderpass layout."]],"trait":[["GenericPipeline",""]]});