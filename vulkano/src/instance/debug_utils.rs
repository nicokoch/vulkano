// Copyright (c) 2016 The vulkano developers
// Licensed under the Apache License, Version 2.0
// <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT
// license <LICENSE-MIT or http://opensource.org/licenses/MIT>,
// at your option. All files in the project carrying such
// notice may not be copied, modified, or distributed except
// according to those terms.

//! Debug callback called by intermediate layers or by the driver.
//!
//! When working on an application, it is recommended to register a debug callback. For example if
//! you enable the validation layers provided by the official Vulkan SDK, they will warn you about
//! invalid API usages or performance problems by calling this callback. The callback can also
//! be called by the driver or by whatever intermediate layer is activated.
//!
//! Note that the vulkano library can also emit messages to warn you about performance issues.
//! TODO: ^ that's not the case yet, need to choose whether we keep this idea
//!
//! # Example
//!
//! ```
//! # use vulkano::instance::Instance;
//! # use std::sync::Arc;
//! # let instance: Arc<Instance> = return;
//! use vulkano::instance::debug_utils::DebugCallback;
//!
//! let _callback = DebugCallback::errors_and_warnings(&instance, |msg| {
//!     println!("Debug callback: {:?}", msg.description);
//! }).ok();
//! ```
//!
//! The type of `msg` in the callback is [`Message`](struct.Message.html).
//!
//! Note that you must keep the `_callback` object alive for as long as you want your callback to
//! be callable. If you don't store the return value of `DebugCallback`'s constructor in a
//! variable, it will be immediately destroyed and your callback will not work.
//!
use std::error;
use std::ffi::CStr;
use std::fmt;
use std::mem;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::slice;
use std::sync::Arc;
// use std::sync::atomic::AtomicUsize;

use instance::Instance;

use Error;
use VulkanObject;
use check_errors;
use vk;

/// Registration of a callback called by validation layers.
///
/// The callback can be called as long as this object is alive.
#[must_use = "The DebugMessenger object must be kept alive for as long as you want your callback \
              to be called"]
pub struct DebugMessenger {
    instance: Arc<Instance>,
    debug_report_callback: vk::DebugUtilsMessengerEXT,
    user_callback: Box<Box<Fn(&MessageSeverities, &MessageTypes, &CallbackData)>>,
}

impl DebugMessenger {
    /// Initializes a debug callback.
    ///
    /// Panics generated by calling `user_callback` are ignored.
    pub fn new<F>(instance: &Arc<Instance>, message_severities: MessageSeverities, message_types: MessageTypes,
                  user_callback: F)
                  -> Result<DebugMessenger, DebugMessengerCreationError>
        where F: Fn(&MessageSeverities, &MessageTypes, &CallbackData) + 'static + Send + panic::RefUnwindSafe
    {
        if !instance.loaded_extensions().ext_debug_utils {
            return Err(DebugMessengerCreationError::MissingExtension);
        }

        // Note that we need to double-box the callback, because a `*const Fn()` is a fat pointer
        // that can't be casted to a `*const c_void`.
        let user_callback = Box::new(Box::new(user_callback) as Box<_>);

        extern "system" fn callback(message_severity: vk::DebugUtilsMessageSeverityFlagBitsEXT,
                                    message_type: vk::DebugUtilsMessageTypeFlagBitsEXT,
                                    p_callback_data: *const vk::DebugUtilsMessengerCallbackDataEXT,
                                    p_user_data: *mut c_void)
                                    -> u32 {
            unsafe {
                let user_callback = p_user_data as *mut Box<Fn()> as *const _;
                let user_callback: &Box<Fn(&MessageSeverities, &MessageTypes, &CallbackData)> = &*user_callback;

                let message_severity = MessageSeverities {
                    verbose: (message_severity & vk::DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT) != 0,
                    info: (message_severity & vk::DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT) != 0,
                    warning: (message_severity & vk::DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) != 0,
                    error: (message_severity & vk::DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT) != 0,
                };

                let message_type = MessageTypes {
                    general: (message_type & vk::DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT) != 0,
                    validation: (message_type & vk::DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT) != 0,
                    performance: (message_type & vk::DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT) != 0,
                };


                let callback_data = {
                    let p_callback_data = &*p_callback_data;
                    debug_assert_eq!(p_callback_data.sType, vk::STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT);
                    debug_assert_eq!(p_callback_data.flags, 0);
                    let message_id_name = CStr::from_ptr(p_callback_data.pMessageIdName).to_str().expect("message_id_name not utf-8");
                    let message = CStr::from_ptr(p_callback_data.pMessage).to_str().expect("message not utf-8");
                    let queue_labels = {
                        let vk_labels = slice::from_raw_parts(p_callback_data.pQueueLabels, p_callback_data.queueLabelCount as usize);
                        let mut labels = Vec::new();
                        for vk_label in vk_labels {
                            debug_assert_eq!(vk_label.sType, vk::STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT);
                            labels.push(
                                Label {
                                    label_name: CStr::from_ptr(vk_label.pLabelName).to_str().expect("label_name not utf-8"),
                                    color: vk_label.color,
                                }
                            );
                        }
                        labels
                    };
                    let cmd_buf_labels = {
                        let vk_labels = slice::from_raw_parts(p_callback_data.pCmdBufLabels, p_callback_data.cmdBufLabelCount as usize);
                        let mut labels = Vec::new();
                        for vk_label in vk_labels {
                            debug_assert_eq!(vk_label.sType, vk::STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT);
                            labels.push(
                                Label {
                                    label_name: CStr::from_ptr(vk_label.pLabelName).to_str().expect("label_name not utf-8"),
                                    color: vk_label.color,
                                }
                            );
                        }
                        labels
                    };

                    let objects = {
                        let vk_objects = slice::from_raw_parts(p_callback_data.pObjects, p_callback_data.objectCount as usize);
                        let mut objects = Vec::new();
                        for vk_object in vk_objects {
                            debug_assert_eq!(vk_object.sType, vk::STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT);
                            debug_assert!(!vk_object.objectType == vk::OBJECT_TYPE_UNKNOWN);
                            objects.push(
                                ObjectNameInfo {
                                    object_type: vk_object.objectType,
                                    object_handle: vk_object.objectHandle,
                                    object_name: CStr::from_ptr(vk_object.pObjectName).to_str().expect("object_name not utf-8")
                                }
                            );
                        }
                        objects
                    };

                    CallbackData {
                        message_id_name: message_id_name,
                        message_id_number: p_callback_data.messageIdNumber,
                        message: message,
                        queue_labels: queue_labels,
                        cmd_buf_labels: cmd_buf_labels,
                        objects: objects,
                    }
                };

                // Since we box the closure, the type system doesn't detect that the `UnwindSafe`
                // bound is enforced. Therefore we enforce it manually.
                let _ = panic::catch_unwind(panic::AssertUnwindSafe(move || {
                                                                        user_callback(&message_severity, &message_type, &callback_data);
                                                                    }));

                vk::FALSE
            }
        }

        let requested_severities = {
            let mut flags = 0;
            if message_severities.verbose {
                flags |= vk::DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT;
            }
            if message_severities.info {
                flags |= vk::DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT;
            }
            if message_severities.warning {
                flags |= vk::DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT;
            }
            if message_severities.error {
                flags |= vk::DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
            }
            flags
        };

        let requested_types = {
            let mut flags = 0;
            if message_types.general {
                flags |= vk::DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT;
            }
            if message_types.validation {
                flags |= vk::DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT;
            }
            if message_types.performance {
                flags |= vk::DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
            }
            flags
        };

        let infos = vk::DebugUtilsMessengerCreateInfoEXT {
            sType: vk::STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
            pNext: ptr::null(),
            flags: 0,
            messageSeverity: requested_severities,
            messageType: requested_types,
            pfnUserCallback: callback,
            pUserData: &*user_callback as &Box<_> as *const Box<_> as *const c_void as *mut _,
        };

        let vk = instance.pointers();

        let debug_utils_messenger = unsafe {
            let mut output = mem::uninitialized();
            check_errors(vk.CreateDebugUtilsMessengerEXT(instance.internal_object(),
                                                         &infos,
                                                         ptr::null(),
                                                         &mut output))?;
            output
        };

        Ok(DebugMessenger {
               instance: instance.clone(),
               debug_report_callback: debug_utils_messenger,
               user_callback: user_callback,
           })
    }
}

impl Drop for DebugMessenger {
    #[inline]
    fn drop(&mut self) {
        unsafe {
            let vk = self.instance.pointers();
            vk.DestroyDebugUtilsMessengerEXT(self.instance.internal_object(),
                                             self.debug_report_callback,
                                             ptr::null());
        }
    }
}

/// A message received by the callback.
pub struct Message<'a> {
    /// Type of message.
    pub ty: MessageTypes,
    /// Prefix of the layer that reported this message.
    pub layer_prefix: &'a str,
    /// Description of the message.
    pub description: &'a str,
}

/// Type of message.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct MessageTypes {
    /// A general problem
    pub general: bool,
    /// Invalid APi usage
    pub validation: bool,
    /// A potential performance problem
    pub performance: bool,
}

/// Severity of message.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct MessageSeverities {
    /// Indicates all diagnostic messages from the Vulkan loader, layers, and drivers should be captured.
    pub verbose: bool,
    /// Specifies an informational message such as resource details that may be handy when debugging an application.
    pub info: bool,
    /// Specifies use of Vulkan that may expose an app bug.
    /// Such cases may not be immediately harmful, such as a fragment shader outputting to a
    /// location with no attachment.
    /// Other cases may point to behavior that is almost certainly bad when unintended
    /// such as using an image whose memory has not been filled.
    /// In general if you see a warning but you know that the behavior is intended/desired,
    /// then simply ignore the warning.
    pub warning: bool,
    /// Specifies that an error that may cause undefined results, including an application crash.
    pub error: bool,
}

/// Data passed to a `DebugMessenger` callback.
#[derive(Debug, Clone, PartialEq)]
pub struct CallbackData<'a> {
    /// Identifies the particular message ID that is associated with the provided message.
    /// If the message corresponds to a validation layer message, then this string may contain
    /// the portion of the Vulkan specification that is believed to have been violated.
    pub message_id_name: &'a str,
    /// The ID number of the triggering message.
    /// If the message corresponds to a validation layer message, then this number is related
    /// to the internal number associated with the message being triggered.
    pub message_id_number: i32,
    /// Contains details about the trigger conditions.
    pub message: &'a str,
    /// The labels active in the current VkQueue at the time the callback was triggered.
    pub queue_labels: Vec<Label<'a>>,
    /// The labels active in the current VkCmdBuffer at the time the callback was triggered.
    pub cmd_buf_labels: Vec<Label<'a>>,
    /// objects related to the detected issue. The array is roughly in order or importance,
    /// but the 0th element is always guaranteed to be the most important object for this message.
    pub objects: Vec<ObjectNameInfo<'a>>,
}

/// A label used by `VK_EXT_DEBUG_UTILS`.
#[derive(Debug, Clone, PartialEq)]
pub struct Label<'a> {
    /// The name of the label.
    pub label_name: &'a str,
    /// RGBA color value that can be associated with the label.
    /// A particular implementation may choose to ignore this color value.
    /// The values contain RGBA values in order, in the range 0.0 to 1.0.
    /// If all elements in color are set to 0.0 then it is ignored.
    pub color: [f32; 4],
}

/// Object information used by `VK_EXT_DEBUG_UTILS`.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ObjectNameInfo<'a> {
    /// The type of the object.
    pub object_type: vk::ObjectType,
    /// The handle of the raw vulkan object.
    pub object_handle: u64,
    /// The name of the object.
    pub object_name: &'a str,
}

/// Error that can happen when creating a debug callback.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum DebugMessengerCreationError {
    /// The `EXT_debug_utils` extension was not enabled.
    MissingExtension,
}

impl error::Error for DebugMessengerCreationError {
    #[inline]
    fn description(&self) -> &str {
        match *self {
            DebugMessengerCreationError::MissingExtension =>
                "the `EXT_debug_utils` extension was not enabled",
        }
    }
}

impl fmt::Display for DebugMessengerCreationError {
    #[inline]
    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        write!(fmt, "{}", error::Error::description(self))
    }
}

impl From<Error> for DebugMessengerCreationError {
    #[inline]
    fn from(err: Error) -> DebugMessengerCreationError {
        panic!("unexpected error: {:?}", err)
    }
}
