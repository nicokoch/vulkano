initSidebarItems({"enum":[["OomError","Error type returned by most Vulkan functions."]],"macro":[["impl_vertex!",""],["single_pass_renderpass!","Builds a `RenderPass` object."]],"mod":[["buffer","Location in memory that contains data.All buffers are guaranteed to be accessible from the GPU.Strong typingAll buffers take a template parameter that indicates their content.MemoryCreating a buffer requires passing an object that will be used by this library to provide memory to the buffer.All accesses to the memory are done through the `Buffer` object.TODO: proof read this section"],["command_buffer","Commands that the GPU will execute (includes draw commands).With Vulkan, before the GPU can do anything you must create a `CommandBuffer`. A command buffer is a list of commands that will executed by the GPU. Once a command buffer is created, you can execute it. A command buffer must be created even for the most simple tasks.PoolsCommand buffers are allocated from pools. You must first create a command buffer pool which you will create command buffers from.A pool is linked to a queue family. Command buffers that are created from a certain pool can only be submitted to queues that belong to that specific family.Primary and secondary command buffers.There are three types of command buffers:**Primary command buffers**. They can contain any command. They are the only type of command buffer that can be submitted to a queue. **Secondary \"graphics\" command buffers**. They contain draw and clear commands. They can be called from a primary command buffer once a framebuffer has been selected. **Secondary \"compute\" command buffers**. They can contain non-draw and non-clear commands (eg. copying between buffers) and can be called from a primary command buffer outside of a render pass. Note that secondary command buffers cannot call other command buffers."],["descriptor_set","Collection of resources accessed by the pipeline.The resources accessed by the pipeline must be accessed through what is called a *descriptor*. Descriptors are grouped in what is called *descriptor sets*. Descriptor sets are also grouped in what is called a *pipeline layout*.Pipeline initializationIn order to build a pipeline object (a `GraphicsPipeline` or a `ComputePipeline`), you have to pass a pointer to a `PipelineLayout<T>` struct. This struct is a wrapper around a Vulkan struct that contains all the data about the descriptor sets and descriptors that will be available in the pipeline. The `T` parameter must implement the `PipelineLayoutDesc` trait and describes the descriptor sets and descriptors on vulkano's side.To build a `PipelineLayout`, you need to pass a collection of `DescriptorSetLayout` structs. A `DescriptorSetLayout<T>` if the equivalent of `PipelineLayout` but for a single descriptor set. The `T` parameter must implement the `DescriptorSetDesc` trait.Binding resourcesIn parallel of the pipeline initialization, you have to create a `DescriptorSet<T>`. This struct contains the list of actual resources that will be bound when the pipeline is executed. To build a `DescriptorSet<T>`, you need to pass a `DescriptorSetLayout<T>`. The `T` parameter must implement `DescriptorSetDesc` as if the same for both the descriptor set and its layout.TODO: describe descriptor set writesShader analyserWhile you can manually implement the `PipelineLayoutDesc` and `DescriptorSetDesc` traits on your own types, it is encouraged to use the `vulkano-shaders` crate instead. This crate will automatically parse your SPIR-V code and generate structs that implement these traits and describe the pipeline layout to vulkano."],["device","Communication channel with a physical device.The `Device` is one of the most important objects of Vulkan. Creating a `Device` is required before you can create buffers, textures, shaders, etc."],["format","Declares all the formats of data and images supported by Vulkan.Content of this moduleThis module contains three things:The `Format` enumeration, which contains all the available formats. The `FormatDesc` trait. One struct for each format. FormatsList of suffixes:`Unorm` means that the values are unsigned integers that are converted into floating points. The maximum possible representable value becomes `1.0`, and the minimum representable value becomes `0.0`. For example the value `255` in a `R8Unorm` will be interpreted as `1.0`.`Snorm` is the same as `Unorm`, but the integers are signed and the range is from `-1.0` to `1.0` instead.`Uscaled` means that the values are unsigned integers that are converted into floating points. No change in the value is done. For example the value `255` in a `R8Uscaled` will be interpreted as `255.0`.`Sscaled` is the same as `Uscaled` expect that the integers are signed.`Uint` means that the values are unsigned integers. No conversion is performed.`Sint` means that the values are signed integers. No conversion is performed.`Ufloat` means that the values are unsigned floating points. No conversion is performed. This format is very unsual.`Sfloat` means that the values are regular floating points. No conversion is performed.`Srgb` is the same as `Unorm`, except that the value is interpreted as being in the sRGB color space. This means that its value will be converted to fit in the RGB color space when it is read. The fourth channel (usually used for alpha), if present, is not concerned by the conversion.Choosing a formatThe following formats are guaranteed to be supported for everything that is related to texturing (ie. blitting source and sampling them linearly). You should choose one of these formats if you have an image that you are going to sample from:// TODO: use vulkano enums - B4G4R4A4_UNORM_PACK16 - R5G6B5_UNORM_PACK16 - A1R5G5B5_UNORM_PACK16 - R8_UNORM - R8_SNORM - R8G8_UNORM - R8G8_SNORM - R8G8B8A8_UNORM - R8G8B8A8_SNORM - R8G8B8A8_SRGB - B8G8R8A8_UNORM - B8G8R8A8_SRGB - A8B8G8R8_UNORM_PACK32 - A8B8G8R8_SNORM_PACK32 - A8B8G8R8_SRGB_PACK32 - A2B10G10R10_UNORM_PACK32 - R16_SFLOAT - R16G16_SFLOAT - R16G16B16A16_SFLOAT - B10G11R11_UFLOAT_PACK32 - E5B9G9R9_UFLOAT_PACK32The following formats are guaranteed to be supported for everything that is related to intermediate render targets (ie. blitting destination, color attachment and sampling linearly):// TODO: use vulkano enums - R5G6B5_UNORM_PACK16 - A1R5G5B5_UNORM_PACK16 - R8_UNORM - R8G8_UNORM - R8G8B8A8_UNORM - R8G8B8A8_SRGB - B8G8R8A8_UNORM - B8G8R8A8_SRGB - A8B8G8R8_UNORM_PACK32 - A8B8G8R8_SRGB_PACK32 - A2B10G10R10_UNORM_PACK32 - R16_SFLOAT - R16G16_SFLOAT - R16G16B16A16_SFLOATFor depth images, only `D16Unorm` is guaranteed to be supported. For depth-stencil images, it is guaranteed that either `D24Unorm_S8Uint` or `D32Sfloat_S8Uint` are supported.// TODO: storage formats"],["framebuffer","Targets on which your draw commands are executed.Render passes and framebuffersThere are two concepts in Vulkan:A `RenderPass` is a collection of rendering passes called subpasses. Each subpass contains the format and dimensions of the attachments that are part of the subpass. The render pass only defines the layout of the rendering process. A `Framebuffer` contains the list of actual images that are attached. It is created from a `RenderPass` and has to match its characteristics. This split means that you can create graphics pipelines from a `RenderPass` alone. A `Framebuffer` is only needed when you add draw commands to a command buffer.Render passesA render pass is composed of three things:A list of attachments with their format. A list of subpasses, that defines for each subpass which attachment is used for which purpose. A list of dependencies between subpasses. Vulkan implementations are free to reorder the subpasses, which means that you need to declare dependencies if the output of a subpass needs to be read in a following subpass. Before you can create a `RenderPass` object with the vulkano library, you have to create an object that can describe these three lists through `RenderPassLayout` trait. This trait is unsafe because the information that its methods return is trusted blindly by vulkano.There are two ways to do this:   TODO add more waysCreating an instance of an `EmptySinglePassLayout`, which describes a renderpass with no attachment and with one subpass. Using the `single_pass_renderpass!` macro. See the documentation of this macro. ExampleWith `EmptySinglePassLayout`:FramebuffersCreating a framebuffer is done by passing the render pass object, the dimensions of the framebuffer, and the list of attachments to `Framebuffer::new()`.The slightly tricky part is that the list of attachments depends on the trait implementation of `RenderPassLayout`. For example if you use an `EmptySinglePassLayout`, you have to pass `()` for the list of attachments.Some implementations of `RenderPassLayout` can use strong typing for the attachments list, in order to produce a compilation error if you pass the wrong kind of attachment. Other implementations may have more relaxed rules and check the format of the attachments at runtime instead."],["image","Images storage (1D, 2D, 3D, arrays, etc.).Strong typingImages in vulkano are strong-typed. Their signature is `Image<Ty, F, M>`.The `Ty` parameter describes the type of image: 1D, 2D, 3D, 1D array, 2D array. All these come in two variants: with or without multisampling. The actual type of `Ty` must be one of the marker structs of this module that start with the `Ty` prefix.The `F` parameter describes the format of each pixel of the image. It must be one of the marker structs of the `formats` module.The `M` parameter describes where the image's memory was allocated from. It is similar to buffers."],["instance","API entry point.Creating an instance initializes everything and allows you to:Enumerate physical devices. Enumerate monitors. Create surfaces. Application infoWhen you create an instance, you have the possibility to pass an `ApplicationInfo` struct. This struct contains various information about your application, most notably its name and engine.Passing such a structure allows for example the driver to let the user configure the driver's behavior for your application alone through a control panel.Enumerating physical devicesAfter you have created an instance, the next step is to enumerate the physical devices that are available on the system with `PhysicalDevice::enumerate()`.When choosing which physical device to use, keep in mind that physical devices may or may not be able to draw to a certain surface (ie. to a window or a monitor). See the `swapchain` module for more info.A physical device can designate a video card, an integrated chip, but also multiple video cards working together. Once you have chosen a physical device, you can create a `Device` from it. See the `device` module for more info."],["memory","GPU-visible memory allocation and management.When you create a buffer or a texture with Vulkan, you have to bind it to a chunk of allocated memory. To do so, you have to pass a type that implements the `MemorySource` trait.There are several implementations of the trait, ie. several things that you can pass to the constructors of buffers and textures:`&Arc<Device>`, which will simply allocate a new chunk of memory every time (easy but not very efficient). `MemorySource`, which is the same as `&Arc<Device>` except that it will use the already-allocated block. ... needs more ... SynchronizationIn Vulkan, it's the job of the programmer to enforce memory safety. In other words, the programmer must take care that two chunks of memory are not read and written simultaneously.In this library, this is enforced by the implementation of `MemorySource` or `MemorySourceChunk`.There are two mechanisms in Vulkan that can provide synchronization: fences and semaphores. Fences provide synchronization between the CPU and the GPU, and semaphores provide synchronization between multiple queues of the GPU. See the `sync` module for more info.Sparse resources**Not yet implemented**.Instead of creating a buffer or an image with a single chunk of memory, you also have the possibility to create resources with *sparse memory*.For example you can bind the first half of the buffer to a memory chunk, and the second half of the buffer to another memory chunk.There is a hierarchy of three features related to sparse resources:The `sparseBinding` feature allows you to use sparse resources. The `sparseResidency` feature is a superset of `sparseBinding` and allows you to leave some parts of the resource unbinded before using it. The `sparseResidencyAliased` feature is a superset of `sparseResidency` and allows you to bind the same memory chunk to multiple different resources at once."],["pipeline",""],["sampler","How to retreive data from an image within a shader.This module contains a struct named `Sampler` which describes how to get pixel data from a texture."],["shader",""],["swapchain","Link between Vulkan and a window and/or the screen.In order to draw on the screen or a window, you have to use two steps:Create a `Surface` object that represents the location where the image will show up. Create a `Swapchain` using that `Surface`. Creating a surface can be done with only an `Instance` object. However creating a swapchain requires a `Device` object.Once you have a swapchain, you can retreive `Image` objects from it and draw to them. However due to double-buffering or other caching mechanism, the rendering will not automatically be shown on screen. In order to show the output on screen, you have to *present* the swapchain by using the method with the same name.ExtensionsTheses capabilities depend on some extensions:`VK_KHR_surface` `VK_KHR_swapchain` `VK_KHR_display` `VK_KHR_display_swapchain` `VK_KHR_xlib_surface` `VK_KHR_xcb_surface` `VK_KHR_wayland_surface` `VK_KHR_mir_surface` `VK_KHR_android_surface` `VK_KHR_win32_surface`"],["sync","Synchronization primitives for Vulkan objects.In Vulkan, you have to manually ensure two things:That a buffer or an image are not read and written simultaneously (similarly to the CPU). That writes to a buffer or an image are propagated to other queues by inserting memory barriers. But don't worry ; this is automatically enforced by this library (as long as you don't use any unsafe function). See the `memory` module for more info."]],"trait":[["SynchronizedVulkanObject","Gives access to the internal identifier of an object."],["VulkanObject","Gives access to the internal identifier of an object."],["VulkanObjectU64",""],["VulkanObjectUsize",""]]});